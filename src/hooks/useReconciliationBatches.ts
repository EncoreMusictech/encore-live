
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';
import { toast } from '@/hooks/use-toast';
import { getQuarterFromDate } from '@/lib/utils';

export interface ReconciliationBatch {
  id: string;
  user_id: string;
  batch_id: string | null;
  source: 'DSP' | 'PRO' | 'YouTube' | 'BMI' | 'ASCAP' | 'SESAC' | 'SOCAN' | 'Spotify' | 'Apple Music' | 'Amazon Music' | 'Tidal' | 'Pandora' | 'SiriusXM' | 'Test Source' | 'Shondaland' | 'Other';
  statement_period_start?: string;
  statement_period_end?: string;
  date_received: string;
  total_gross_amount: number;
  allocated_amount?: number; // Sum of allocated royalties
  reconciliation_status?: 'Complete' | 'Incomplete'; // Calculated field
  linked_statement_id?: string;
  statement_file_url?: string;
  status: 'Pending' | 'Imported' | 'Processed';
  notes?: string;
  created_at: string;
  updated_at: string;
}

export function useReconciliationBatches() {
  const [batches, setBatches] = useState<ReconciliationBatch[]>([]);
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();

  const fetchBatches = async () => {
    if (!user) return;
    
    try {
      // First get the batches
      const { data: batchData, error: batchError } = await supabase
        .from('reconciliation_batches')
        .select('*')
        .order('created_at', { ascending: false });

      if (batchError) throw batchError;

      // Then get the allocated amounts for each batch
      const batchesWithAllocations = await Promise.all(
        (batchData || []).map(async (batch) => {
          let allocated_amount = 0;

          // Get the sum of gross_royalty_amount for all allocations linked to this batch via batch_id
          const { data: allocations, error: allocError } = await supabase
            .from('royalty_allocations')
            .select('gross_royalty_amount')
            .eq('batch_id', batch.id);

          if (allocError) {
            console.warn(`Error fetching allocations for batch ${batch.id}:`, allocError);
          } else {
            allocated_amount += allocations?.reduce((sum, allocation) => 
              sum + (allocation.gross_royalty_amount || 0), 0) || 0;
          }

          // If batch has a linked statement, also include royalties from that statement
          if (batch.linked_statement_id) {
            // First get the staging record to find its statement_id
            const { data: stagingRecord } = await supabase
              .from('royalties_import_staging')
              .select('statement_id')
              .eq('id', batch.linked_statement_id)
              .single();

            if (stagingRecord?.statement_id) {
              // Search for royalties using the staging record's statement_id
              const { data: statementRoyalties } = await supabase
                .from('royalty_allocations')
                .select('gross_royalty_amount')
                .eq('user_id', user.id)
                .eq('statement_id', stagingRecord.statement_id);

              if (statementRoyalties && statementRoyalties.length > 0) {
                allocated_amount += statementRoyalties.reduce((sum, allocation) => 
                  sum + (allocation.gross_royalty_amount || 0), 0);
              }
            }
          }

          // Calculate reconciliation status
          const reconciliation_status: 'Complete' | 'Incomplete' = Math.abs(allocated_amount - batch.total_gross_amount) < 0.01 
            ? 'Complete' 
            : 'Incomplete';

          return { ...batch, allocated_amount, reconciliation_status };
        })
      );

      setBatches(batchesWithAllocations);
    } catch (error: any) {
      console.error('Error fetching batches:', error);
      toast({
        title: "Error",
        description: "Failed to fetch reconciliation batches",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const createBatch = async (batchData: Omit<ReconciliationBatch, 'id' | 'user_id' | 'batch_id' | 'created_at' | 'updated_at'>) => {
    if (!user) return null;

    try {
      const { data, error } = await supabase
        .from('reconciliation_batches')
        .insert({
          ...batchData,
          user_id: user.id,
          batch_id: null, // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;

      toast({
        title: "Success",
        description: `Reconciliation batch ${data.batch_id} created successfully`,
      });

      await fetchBatches();
      return data;
    } catch (error: any) {
      console.error('Error creating batch:', error);
      toast({
        title: "Error",
        description: "Failed to create reconciliation batch",
        variant: "destructive",
      });
      return null;
    }
  };

  const updateBatch = async (id: string, batchData: Partial<ReconciliationBatch>) => {
    try {
      const { data, error } = await supabase
        .from('reconciliation_batches')
        .update(batchData)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      // If the batch status is being updated to 'Processed', also update the linked import staging record
      if (batchData.status === 'Processed' && data.linked_statement_id) {
        console.log('Updating linked import staging record status to processed');
        
        const { error: stagingUpdateError } = await supabase
          .from('royalties_import_staging')
          .update({ 
            processing_status: 'processed'
          })
          .eq('id', data.linked_statement_id);

        if (stagingUpdateError) {
          console.error('Error updating staging record status:', stagingUpdateError);
          // Don't fail the whole operation, just log the error
          toast({
            title: "Warning",
            description: "Batch updated but failed to sync import staging status",
            variant: "destructive",
          });
        } else {
          console.log('Successfully updated linked import staging record status');
        }
      }

      toast({
        title: "Success",
        description: "Reconciliation batch updated successfully",
      });

      await fetchBatches();
      return data;
    } catch (error: any) {
      console.error('Error updating batch:', error);
      toast({
        title: "Error",
        description: "Failed to update reconciliation batch",
        variant: "destructive",
      });
      return null;
    }
  };

  const deleteBatch = async (id: string) => {
    try {
      const { error } = await supabase
        .from('reconciliation_batches')
        .delete()
        .eq('id', id);

      if (error) throw error;

      toast({
        title: "Success",
        description: "Reconciliation batch deleted successfully",
      });

      await fetchBatches();
    } catch (error: any) {
      console.error('Error deleting batch:', error);
      toast({
        title: "Error",
        description: "Failed to delete reconciliation batch",
        variant: "destructive",
      });
    }
  };

  const linkBatchToAllocations = async (batchId: string, allocationIds: string[]) => {
    try {
      // First, get the batch's date_received to calculate the quarter
      const { data: batch, error: batchError } = await supabase
        .from('reconciliation_batches')
        .select('date_received')
        .eq('id', batchId)
        .single();

      if (batchError) throw batchError;
      
      // Calculate quarter from the batch's date_received
      const quarter = getQuarterFromDate(batch.date_received);

      // Update all specified allocations to link them to this batch and set the quarter
      const updatePromises = allocationIds.map(allocationId =>
        supabase
          .from('royalty_allocations')
          .update({ 
            batch_id: batchId,
            quarter: quarter
          })
          .eq('id', allocationId)
      );

      const results = await Promise.all(updatePromises);
      
      // Check for any errors
      const errors = results.filter(result => result.error);
      if (errors.length > 0) {
        throw new Error(`Failed to link ${errors.length} allocations`);
      }

      toast({
        title: "Success",
        description: `Successfully linked ${allocationIds.length} allocation${allocationIds.length !== 1 ? 's' : ''} to batch with quarter ${quarter}`,
      });

      await fetchBatches();
      return true;
    } catch (error: any) {
      console.error('Error linking batch to allocations:', error);
      toast({
        title: "Error",
        description: "Failed to link allocations to batch",
        variant: "destructive",
      });
      return false;
    }
  };

  const unlinkStatement = async (id: string) => {
    try {
      const { data, error } = await supabase
        .from('reconciliation_batches')
        .update({ linked_statement_id: null })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      // Update the local state
      setBatches(prevBatches => 
        prevBatches.map(batch => 
          batch.id === id 
            ? { ...batch, linked_statement_id: null }
            : batch
        )
      );

      toast({
        title: "Success",
        description: "Statement unlinked from batch successfully",
      });

      return data;
    } catch (error) {
      console.error('Error unlinking statement:', error);
      toast({
        title: "Error",
        description: "Failed to unlink statement from batch",
        variant: "destructive",
      });
      return null;
    }
  };

  useEffect(() => {
    fetchBatches();
  }, [user]);

  return {
    batches,
    loading,
    createBatch,
    updateBatch,
    deleteBatch,
    linkBatchToAllocations,
    unlinkStatement,
    refreshBatches: fetchBatches,
  };
}
